#region License

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#endregion

namespace Endjin.Templify.Specifications.Domain.Packager.Tokeniser
{
    #region Using Directives

    using System;
    using System.Collections.Generic;

    using Endjin.Templify.Domain.Contracts.Packager.Filters;
    using Endjin.Templify.Domain.Contracts.Packager.Processors;
    using Endjin.Templify.Domain.Domain.Packager.Tokeniser;
    using Endjin.Templify.Domain.Domain.Packages;

    using Machine.Specifications;
    using Machine.Specifications.AutoMocking.Rhino;

    using Rhino.Mocks;

    #endregion

    public abstract class specification_for_package_tokeniser : Specification<PackageTokeniser>
    {
        protected static IRenameFileProcessor rename_file_processor;
        protected static IFileContentProcessor file_content_processor;
        protected static IBinaryFileFilter binary_file_filter;
        protected static Package package_to_tokenise;
        protected static List<ManifestFile> filtered_files;

        Establish context = () =>
            {
                rename_file_processor = DependencyOf<IRenameFileProcessor>();
                binary_file_filter = DependencyOf<IBinaryFileFilter>();
                file_content_processor = DependencyOf<IFileContentProcessor>();

                package_to_tokenise = new Package
                {
                    ClonedPath = @"C:\Temp\Endjin\Templify\tmp-repo\a67013ef-0ec8-405b-9868-fb5bfdcf2dad\Cloned",
                    Manifest = new Manifest
                    {
                        Author = "Howard van Rooijen",
                        Id = Guid.NewGuid(),
                        InstallRoot = @"c:\Temp\Package-Goes-Here",
                        Name = "Temporary Package",
                        Path = @"c:\Temp\Package-Goes-Here",
                        Version = "1.0.0.1",
                        Files = new List<ManifestFile>
                                {
                                    new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.dll", },
                                    new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.pdf", },
                                    new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.txt", },
                                    new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.cs", },
                                    new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.config", },
                                }
                    },
                    TemplatePath = @"C:\Temp\Endjin\Templify\tmp-repo\a67013ef-0ec8-405b-9868-fb5bfdcf2dad\Template"
                    
                };
                filtered_files = new List<ManifestFile>
                    {
                        new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.txt", },
                        new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.cs", },
                        new ManifestFile { File = @"C:\MyApp\.git\hooks\applypatch-msg.config", },
                    };
            };
    }

    [Subject(typeof(PackageTokeniser))]
    public class when_the_package_tokenise_is_asked_to_tokenise_a_package : specification_for_package_tokeniser
    {
        static Package result;

        Establish context = () =>
            {
                binary_file_filter.Stub(c => c.Filter(package_to_tokenise.Manifest.Files)).Return(filtered_files);
                file_content_processor.Stub(c => c.ReadContents("anyfile.cs")).IgnoreArguments().Return(@"\_NAME_\something\");
                rename_file_processor.Stub(c => c.Process("oldName", "newName")).IgnoreArguments();
            };

        Because of = () => result = subject.Tokenise(package_to_tokenise, new Dictionary<string, string>{ { "TokenName", "TokenValue" } });

        It should_contain_five_manifest_files = () =>
            result.Manifest.Files.Count.ShouldEqual(5);

        It should_ask_the_rename_file_processor_to_rename_the_file = () =>
            rename_file_processor.AssertWasCalled(c => c.Process("oldName", "newName"), r => r.IgnoreArguments());

        It should_ask_the_file_content_processor_to_process_the_file_contents = () =>
            file_content_processor.AssertWasCalled(c => c.ReadContents(""), r => r.IgnoreArguments());

        It should_ask_the_binary_file_filter_to_remove_binary_files_whose_contents_wont_tokenize = () =>
            binary_file_filter.AssertWasCalled(c => c.Filter(package_to_tokenise.Manifest.Files), r => r.IgnoreArguments());
    }
}