#region License

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#endregion

namespace Endjin.Templify.Specifications.Domain.Packager.Builders
{
    #region Using Directives

    using System;
    using System.Collections.Generic;

    using Endjin.Templify.Domain.Contracts.Packager.Processors;
    using Endjin.Templify.Domain.Domain.Packager.Builders;
    using Endjin.Templify.Domain.Domain.Packages;
    using Endjin.Templify.Domain.Infrastructure;

    using Machine.Specifications;
    using Machine.Specifications.AutoMocking.Rhino;

    using Rhino.Mocks;

    #endregion

    public abstract class specification_for_clone_package_builder : Specification<ClonePackageBuilder>
    {
        protected static ICloneFileProcessor clone_file_processor;
        protected static Package package_to_clone;

        Establish context = () =>
            {
                clone_file_processor = DependencyOf<ICloneFileProcessor>();
                package_to_clone = new Package
                {
                    Manifest = new Manifest
                        {
                            Author = "Howard van Rooijen",
                            Id = Guid.NewGuid(),
                            InstallRoot = @"c:\Temp\Package-Goes-Here",
                            Name = "Temporary Package",
                            Path = @"c:\Temp\Package-Goes-Here",
                            Version = "1.0.0.1",
                            Files = new List<ManifestFile>
                                {
                                    new ManifestFile { File = @"Sharp-Architecture\Build\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\ReferencedAssemblies\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.Framework\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.Infrastructure\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.Specifications\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.Tasks\placeholder.txt", },
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.WebCore\placeholder.txt", }, 
                                    new ManifestFile { File = @"Sharp-Architecture\Solutions\MyApp.WebViews\placeholder.txt", },
                                }
                        }
                };
        };
    }

    [Subject(typeof(ClonePackageBuilder))]
    public class when_the_clone_package_builder_is_asked_to_clone_a_package : specification_for_clone_package_builder
    {
        static Package result;

        Establish context = () => clone_file_processor.Stub(c => c.Process("fromFilePath", "toFilePath")).IgnoreArguments();

        Because of = () => result = subject.Build(package_to_clone);

        It should_ask_the_clone_file_processor_to_clone_the_file = () =>
            clone_file_processor.AssertWasCalled(c => c.Process("fromFilePath", "toFilePath"), r => r.IgnoreArguments());

        It should_return_the_a_clone_of_the_package = () => 
            result.ShouldNotBeNull();

        It should_return_a_package_which_has_a_matching_number_of_file_and_directories = () => 
            result.Manifest.Files.Count.ShouldEqual(package_to_clone.Manifest.Files.Count);

        It should_return_a_package_where_all_files_have_been_rebased_to_the_temporary_package_repository = () =>
            {
                foreach (var file in result.Manifest.Files)
                {
                    file.File.ShouldStartWith(FilePaths.TemporaryPackageRepository);
                }
            };
    }
}